<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Присвоение по ссылке и по значению</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <section>
        <a href="../3_arrays.html"><<назад</a>
        <h1>Присвоение по ссылке и по значению</h1>
        <p>
Фундаментальным отличием сложных типов от примитивов, является то, как они хранятся и копируются. Примитивы: строки, числа, були,null и undefined, при присваивании копируются целиком, по значению (by value).
<br><br>
Со сложными типами всё не так. В переменной, которой присвоен массив или объект, хранится не само значение, а адрес его места в памяти, иными словами - ссылка (указатель) на него и передаются они по ссылке (by reference).
<br><br>
Представим переменную в виде листа бумаги. Её значение мы представим в виде записи на этом листе.
<br><br>
Если мы захотим сообщить содержимое этой записи пользователям, то можем поступить так - сделать физические копии и вручить их каждому, то есть сделать множественные независимые копии (присвоение по значению).
<br><br>
Или поместить лист в закрытой комнате и дать пользователям ключ от этой комнаты, то есть один экземпляр с общим доступом (присвоение по ссылке).
<br><br>
Теперь изменим данные на листе бумаги - значение переменной. Очевидно, что посетители комнаты всегда будут видеть изменения которые мы вносим, так как изменяется оригинал и они имеют к нему доступ. И также очевидно, что владельцы бумажных копий не заметят изменений глядя на свои копии.
<br><br>
При передаче по значению, переменным выделяется новая ячейка памяти и в нее копируются данные. Аналогия с множественными копиями бумажного листа имеет вполне реальное воплощение, отдельный лист для каждой копии.
<br><br>
При передаче по ссылке, вместо создания нового объекта, переменной присваивается ссылка (указатель) на уже существующий объект, то есть на его место в памяти. Таким образом, несколько переменных могут указывать на один и тот же объект, по аналогии с закрытой комнатой, у них есть ключ доступа к оригиналу листа.
<br><br>
Все примитивные типы присваиваются по значению, то есть создается копия.

<code>
    let a = 5;
<br> // Присвоение по значению, в памяти будет создана еще
<br> // одна ячейка в которую будет скопировано значение 5
<br> let b = a;
<br> console.log(a); // 5
<br> console.log(b); // 5
<br> 
<br> // Изменим значение a
<br> a = 10;
<br> console.log(a); // 10
<br> // Значение b не изменилось так как это отдельная копия
<br> console.log(b); // 5
</code>

Сложные типы - объекты, массивы, функции присваиваются по ссылке, то есть переменная просто получает ссылку на уже существующий объект.

<code>
    const a = ["Mango"];
<br> // Так как a это массив, в b записывается ссылка на уже существующий
<br> // массив в памяти. Теперь a и b указывают на один и тот же массив.
<br> const b = a;
<br> console.log(a); // ["Mango"]
<br> console.log(b); // ["Mango"]
<br> 
<br> // Изменим массив, добавив еще один элемент, используя указатель из a
<br> a.push("Poly");
<br> console.log(a); // ["Mango", "Poly"]
<br> 
<br> // b также изменилось, потому что b, как и a,
<br> // просто содержит ссылку на одно и то же место в памяти
<br> console.log(b); // ["Mango", "Poly"]
<br> 
<br> // Результат повторяется
<br> b.push("Ajax");
<br> console.log(a); // ["Mango", "Poly", "Ajax"]
<br> console.log(b); // ["Mango", "Poly", "Ajax"]
</code>
        </p>
    </section>
</body>
</html>