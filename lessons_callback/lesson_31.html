<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Стрелочные функции</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <section>
        <a href="../7_callback_arrowFn.html"><<назад</a>
        <h1>Стрелочные функции</h1>
        <p>
Стрелочные функции имеют сокращённый, более лаконичный синтаксис, что уменьшает объем кода, особенно когда функция маленькая или если она используется как коллбек.
<br><br>
Все стрелки создаются как функциональное выражение, и если функция не анонимна, то она должна быть присвоена переменной.
<code>

// Обычное объявление функции
<br> function classicAdd(a, b, c) {
<br>   return a + b + c;
<br> }
<br> 
<br> // Тоже самое как стрелочная функция
<br> const arrowAdd = (a, b, c) => {
<br>   return a + b + c;
<br> };
</code>

Ключевое слово <span> function</span> не используется, вместо этого сразу идёт объявление параметров, за которыми следует символ => и тело функции.
<br><br>
Если параметров несколько, то они перечисляются через запятую в круглых скобках, между знаками равно = и стрелкой =>.

<code>
  const add = (a, b, c) => {
<br>   return a + b + c;
<br> };
</code>

Если параметр один, его объявление может быть без круглых скобок.

<code>
  const add = a => {
<br>   return a + 5;
<br> };
</code>

Если параметров нет, то обязательно должны быть пустые круглые скобки.

<code>
  const greet = () => {
<br>   console.log("Привет!");
<br> };
</code>

<h2>
  Неявный возврат
</h2>

В стрелочной функции после символа <span>=></span> идёт её тело. Здесь может быть два варианта: с фигурными скобками и без них.

<code>
  const add = (a, b, c) => {
<br>   console.log(a, b, c);
<br>   return a + b + c;
<br> };
</code>

Если фигурные скобки есть, и функция должна возвращать какое-то значение, необходимо явно поставить return. Это называется явный возврат (explicit return). Такой синтаксис используется в том случае, если в теле функции нужно выполнить ещё какие-то инструкции кроме возврата значения.

<code>
  const add = (a, b, c) => a + b + c;
</code>

Если фигурных скобок нет, то возвращается результат выражения стоящего после <span>=></span>. Это называется неявный возврат (implicit return). В примере вернётся результат выражения сложения параметров a, b и c.
<br><br>
Синтаксис неявного возврата сильно сокращает «шум» объявления функции с телом и возвращаемым выражением, но подходит только в случае когда в теле функции не нужно выполнять никаких дополнительных инструкций кроме возврата значения.

<code>
  // До
<br> function classicAdd(a, b, c) {
<br>   return a + b + c;
<br> }
<br> 
<br> // После
<br> const arrowAdd = (a, b, c) => a + b + c;
</code>

<h2>
  Псевдомассив arguments
</h2>

У стрелочных функций нет локальной переменной arguments, содержащей все аргументы. Если необходимо собрать все аргументы в массив, используется операция rest.

<code>
  const add = (...args) => {
<br>   console.log(args);
<br> };
<br> 
<br> add(1, 2, 3); // [1, 2, 3]
</code>

<h2>
  Стрелочные функции как коллбеки
</h2>

Анонимные стрелочные функции отлично подходят как коллбеки для перебирающих методов массива из-за более краткого синтаксиса объявления, особенно если не нужно тело функции.

<code>
const numbers = [5, 10, 15, 20, 25];
<br> 
<br> // Объявление функции
<br> numbers.forEach(function (number, index) {
<br>   console.log(`Индекс ${index}, значение ${number}`);
<br> });
<br> 
<br> // Анонимная стрелочная функция
<br> numbers.forEach((number, index) => {
<br>   console.log(`Индекс ${index}, значение ${number}`);
<br> });
</code>

Стрелочную коллбек-функцию также можно объявлять отдельно и передавать на неё ссылку. Это стоит делать если одна функция используется в нескольих местах программы или если она громоздкая.

<code>
  const numbers = [5, 10, 15, 20, 25];
<br> 
<br> const logMessage = (number, index) => {
<br>   console.log(`Индекс ${index}, значение ${number}`);
<br> };
<br> 
<br> numbers.forEach(logMessage);
</code>
        </p>
    </section>
</body>
</html>