<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Разновидности кода</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <section>
        <a href="../7_callback_arrowFn.html"><<назад</a>
        <h1>Разновидности кода</h1>
        <p>
<h2>
  Императивное программирование
</h2>

Описывает процесс вычисления в виде заданной последовательности инструкций, изменяющих состояние программы. Описание того, как что-то выполняется.
<br><br>
Императивный стиль программирования - это такой, который дает машине набор детальных инструкций для выполнения задачи. Например цикл for, который предоставляет точные указания для итерации по индексам массива.
<br><br>
Можно провести аналогию с рецептом приготовления блюда. Рецепт - это набор пошаговых инструкций для получения желаемого результата.

<h2>
  Декларативное программирование
</h2>

Описывает то, что мы хотим получить в результате, а не как это сделать. Порядок выполнения и способ достижения не важен.
<br><br>
Когда мы пишем HTML-код, то декларативно, при помощи тегов и атрибутов, описываем то, что хотим получить в результате. Браузер читает этот код и сам выполняет все необходимые операции по созданию HTML-элементов и помещению их на страницу.
<br><br>
Можно провести аналогию с меню ресторана. Это декларативный набор возможных к заказу блюд, детали приготовления и подачи которых скрыты.
<br><br>
Декларативное описание задачи более наглядно и легче формулируется. Мы говорим, что хотим сделать, вызвав метод или функцию. Ее реализация, скорее всего использует императивный код, но он скрыт внутри и не усложняет понимание основного кода.

<h2>
  Императивный vs декларативный
</h2>

Рассмотрим разницу подходов на примере базовой операции фильтрации коллекции. Напишем код перебора и фильтрации массива чисел по какому-то критерию.

<code>
  // Императивный подход
<br> const numbers = [1, 2, 3, 4, 5];
<br> const filteredNumbers = [];
<br> 
<br> for (let i = 0; i < numbers.length; i += 1) {
<br>   if (numbers[i] > 3) {
<br>     filteredNumbers.push(numbers[i]);
<br>   }
<br> }
<br> 
<br> console.log(filteredNumbers); // [4, 5]
</code>

Метод <span>filter()</span> скрывает в себе логику перебора коллекции и вызывает callback-функцию, которую мы ему передаем для каждого элемента, возвращая массив элементов, подошедших под критерий.

<code>
  // Декларативный подход
<br> const numbers = [1, 2, 3, 4, 5];
<br> const filteredNumbers = numbers.filter(value => value > 3);
<br> console.log(filteredNumbers); // [4, 5]
</code>
        </p>
    </section>
</body>
</html>