<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Функции</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <section>
        <a href="../4_function.html"><<назад</a>
        <h1>Функции</h1>
        <p>
Функция - это подпрограмма, независимая часть кода, предназначенная для многократного выполнения конкретной задачи с разными начальными значениями. Функции позволяют структурировать большие программы, уменьшают повторение и изолируют код.
<br><br>
Функцию можно представить как чёрный ящик, она получает что-то на входе (данные), и возвращает что-то на выходе (результат выполнения кода внутри неё).

<h2>
  Объявление функции
</h2>

<code>
  // 1. Объявление функции multiply
<br> function multiply() {
<br>   // Тело функции
<br>   console.log("Это лог при вызове функции multiply");
<br> }
<br> 
<br> // 2. Вызовы функции multiply
<br> multiply(); // 'Это лог при вызове функции multiply'
<br> multiply(); // 'Это лог при вызове функции multiply'
<br> multiply(); // 'Это лог при вызове функции multiply'
</code>


Объявление функции (function declaration) начинается с ключевого слова function, за которым идёт её имя - глагол отвечающий на вопрос «Что сделать?» и пара круглых скобок.
<br><br>
Тело функции заключено в фигурные скобки {} и содержит инструкции которые необходимо выполнить при её вызове. Затем, когда необходимо, функция вызывается с помощью имени и пары круглых скобок.

<h2>
  Параметры и аргументы
</h2>

В круглых скобках после имени функции идут параметры - перечисление данных которые функция ожидает при вызове.

<code>
  // Объявление параметров x, y, z
<br> function multiply(x, y, z) {
<br>   console.log(`Результат умножения равен ${x * y * z}`);
<br> }
</code>

Параметры это локальные переменные доступные только в теле функции. Они разделяются запятыми. Параметров может быть несколько, или вообще не быть, тогда записываются просто пустые круглые скобки.

<h4>
  ИНТЕРЕСНО
Параметры будут создаваться заново каждый раз при вызове функции, и их отдельные инкарнации никак друг с другом не связаны.

</h4>

При вызове функции, в круглых скобках можно передать аргументы - значения для объявленных параметров функции.

<code>
  // 1. Объявление параметров x, y, z
<br> function multiply(x, y, z) {
<br>   console.log(`Результат умножения равен ${x * y * z}`);
<br> }
<br> 
<br> // 2. Передача аргументов
<br> multiply(2, 3, 5); // Результат умножения равен 30
<br> multiply(4, 8, 12); // Результат умножения равен 384
<br> multiply(17, 6, 25); // Результат умножения равен 2550
</code>

<h4>
  ИНТЕРЕСНО
Порядок передачи аргументов должен соответствует порядку объявленых параметров: значение первого аргумента будет присвоено первому параметру, второго аргумента второму параметру и т. д. Если параметров будет больше чем аргументов, то параметрам без значений будет присвоено undefined.

</h4>

<h2>
  Возврат значения
</h2>

Оператор <span>return</span> используется для передачи значения из тела функции во внешний код. Когда интерпретатор встречает return, он сразу же выходит из функции (прекращает её выполнение), и возвращает указанное значение в то место кода, где функция была вызвана.

<code>
  function multiply(x, y, z) {
<br>   console.log("Код до return выполняется как обычно");
<br> 
<br>   // Возвращаем результат выражения умножения
<br>   return x * y * z;
<br> 
<br>   console.log("Этот лог никогда не выполнится, он стоит после return");
<br> }
<br> 
<br> // Результат работы функции можно сохранить в переменную
<br> let result = multiply(2, 3, 5);
<br> console.log(result); // 30
<br> 
<br> result = multiply(4, 8, 12);
<br> console.log(result); // 384
<br> 
<br> result = multiply(17, 6, 25);
<br> console.log(result); // 2550
</code>


<h4>
  ИНТЕРЕСНО
Оператор return без явно указанного значения возвращает специальное значение undefined. При отсутствии return в теле функции, она все равно вернёт undefined.

</h4>

<h2>
  Порядок выполнения кода
</h2>

Когда интерпретатор встречает вызов функции (или метода), он приостанавливает выполнение текущего кода и начинает выполнять код из тела функции. После того как весь код функции будет выполнен, интерпретатор выходит из тела функции, возвращаясь в то место, откуда пришел и продолжает выполнять код, следующий после вызова функции.

<code>
  function multiply(x, y, z) {
<br>   console.log(`Результат умножения равен ${x * y * z}`);
<br> }
<br> 
<br> console.log("Лог до вызова функции multiply");
<br> multiply(2, 3, 5); // Результат умножения равен 30
<br> console.log("Лог после вызова функции multiply");
<br> 
<br> // Последовательность логов в консоли
<br> // "Лог до вызова функции multiply"
<br> // "Результат умножения равен 30"
<br> // "Лог после вызова функции multiply"
</code>

<h2>
  Параметры по умолчанию
</h2>

Иногда необходимо объявить функцию, у параметров которой будут значения отличные от undefined, даже если для них не передали аргументы. Это делается очень простым и очевидным образом, достаточно указать значение по умолчанию прямо при объявлении параметров в подписи функции. При такой записи, если для параметра не передано значение аргумента, используется значение по умолчанию.

<code>
  function count(countFrom = 0, countTo = 10, step = 1) {
 <br>  console.log(`countFrom = ${countFrom}, countTo = ${countTo}, step = ${step}`);
<br> 
<br>   for (let i = countFrom; i <= countTo; i += step) {
<br>     console.log(i);
<br>   }
<br> }
<br> 
<br> count(1, 5); // countFrom = 1, countTo = 5, step = 1
<br> count(2); // countFrom = 2, countTo = 10, step = 1
<br> count(); // countFrom = 0, countTo = 10, step = 1
</code>


<h2>
  Псевдомассив arguments
</h2>

Доступ к списку всех аргументов можно получить при помощи специальной переменной arguments, которая доступна только внутри функции и хранит все аргументы как псевдомассив.
<br><br>
Псевдомассив - коллекция, со свойством length и возможностью обратиться к элементу по индексу, но отсутствием большинства методов для работы с массивом.
<br> <br>
Рассмотрим пример использования arguments в функции, которая умножает любое количество аргументов:

<code>
  function multiply() {
<br>   let total = 1;
<br> 
<br>   for (const argument of arguments) {
<br>     total *= argument;
<br>   }
<br> 
<br>   return total;
<br> }
<br> 
<br> console.log(multiply(1, 2, 3)); //  6
<br> console.log(multiply(1, 2, 3, 4)); //  24
<br> console.log(multiply(1, 2, 3, 4, 5)); //  120
</code>

<h2>
  Преобразование псевдомассива
</h2>
Обычно псевдомассив необходимо преобразовать в полноценный массив, так как у псевдомассива нет методов массива, например slice() или includes(). На практике применяют несколько основных способов.
<br><br>
Используя метод Array.from(), который создаст массив из псевдомассива.

<code>
  function fn() {
<br>  // В переменной args будет полноценный массив
<br>  const args = Array.from(arguments);
<br>}
</code>

Используя операцию <span>...</span> (rest), она позволяет собрать произвольное количество элементов, в нашем случае аргументов, в массив и сохранить его в переменную. Собираем все аргументы используя операцию rest прямо в подписи функции.

<code>
  function fn(...args) {
<br>  // В переменной args будет полноценный массив
<br>}
</code>

<h4>
  ИНТЕРЕСНО
Операция rest более детально рассматривается дальше в курсе, здесь показано одно из ее возможных применений.

</h4>

<h2>
  Паттерн «Ранний возврат»
</h2>

Оператор <span>if...else</span> - это основной способ создания ветвлений. Тем не менее, сложные вложенные ветвления делают код запутанным для понимания.
<br><br>
Создадим функцию, которая обрабатывает снятие денег с личного счета в банке. Она получает сумму для снятия и текущий баланс счета, после чего, в зависимости от условия, выполняет тот или иной блок кода.

<code>
  function withdraw(amount, balance) {
<br>   if (amount === 0) {
<br>     console.log("Для проведения операции введите сумму больше нуля");
<br>   } else if (amount > balance) {
<br>     console.log("Недостаточно средств на счету");
<br>   } else {
<br>     console.log("Операция снятия средств проведена успешно");
<br>   }
<br> }
<br> 
<br> withdraw(0, 300); // "Для проведения операции введите сумму больше нуля"
<br> withdraw(500, 300); // "Недостаточно средств на счету"
<br> withdraw(100, 300); // "Операция снятия средств проведена успешно"
</code>

Даже в таком простом примере есть группа вложенных условных операторов, среди которых не сразу можно выделить понять логику выполнения кода.
<br><br>
В функции может быть больше одного оператора return. Главное помнить, что выполнение функции прерывается когда интерпретатор встречает возврат, и весь код после него будет проигнорирован в текущем вызове функции.
<br><br>
Паттерн «Ранний возврат» - это способ использовать возможность досрочного возврата из функции с помощью оператора return. Используя этот приём мы получаем более чистый, плоский и понятный код, который легче рефакторить.
<br><br>
Выделим все проверки условий в отдельные операторы if, после чего добавим код, идущий в теле else. В идеальном случае, должен получиться плоский список условных операторов, идущих один за другим, а в конце блок, который выполнится только в том случае, если не выполнится ни один if.

<code>
  function withdraw(amount, balance) {
<br>   // Если  условие выполняется, вызывается console.log
<br>   // и выход из функции. Код идущий после тела if не выполнится.
<br>   if (amount === 0) {
<br>     console.log("Для проведения операции введите сумму больше нуля");
<br>     return;
<br>   }
<br> 
<br>   // Если условие первого if не выполнилось, его тело пропускается
<br>   // и интерпретатор доходит до второго if.
<br>   // Если условие выполняется, вызывается console.log и выход из функции.
<br>   // Код идущий после тела if  не выполнится.
<br>   if (amount > balance) {
 <br>    console.log("Недостаточно средств на счету");
<br>     return;
<br>   }
<br> 
<br>   // Если ни один из предыдущих if не выполнился,
<br>   // интерпретатор доходит до этого кода и выполняет его.
<br>   console.log("Операция снятия средств проведена");
<br> }
<br> 
<br> withdraw(0, 300); // "Для проведения операции введите сумму больше нуля"
<br> withdraw(500, 300); // "Недостаточно средств на счету"
<br> withdraw(100, 300); // "Операция снятия средств проведена"
</code>

<h2>
  Функциональное выражение
</h2>

Функциональное выражение (function expression) - обычное объявление переменной, значение которой будет функция. Альтернативный способ объявления функции.

<code>
  // Объявление функции (function declaration)
<br> function multiply(x, y, z) {
<br>   console.log(`Результат умножения равен ${x * y * z}`);
<br> }
<br> 
<br> // Функциональное выражение (function expression)
<br> const multiply = function (x, y, z) {
<br>   console.log(`Результат умножения равен ${x * y * z}`);
<br> };
</code>

Различие в том, что функциональное выражение нельзя вызвать до места его создания, только после, потому что это буквально объявление const переменной.

<code>
  // ❌ Ошибка! Не работает вызов до объявления
<br> multiply(1, 2, 3);
<br> 
<br> const multiply = function (x, y, z) {
<br>   console.log(`Результат умножения равен ${x * y * z}`);
<br> };
<br> 
<br> // ✅ Работает вызов после объявления
<br> multiply(4, 5, 6);
</code>

A объявление функции можно вызвать до места её создания в коде.

<code>
  // ✅ Работает вызов до объявления
<br> multiply(1, 2, 3);
<br> 
<br> function multiply(x, y, z) {
<br>   console.log(`Результат умножения равен ${x * y * z}`);
<br> }
<br> 
<br> // ✅ Работает вызов после объявления
<br> multiply(4, 5, 6);
</code>

<h4>
  ИНТЕРЕСНО
Не важно какой синтаксис использовать, главное чтобы код в проекте был однородным. То есть необходимо стараться не мешать объявления функции с функциональными выражениями.
</h4>
</p>
    </section>
</body>
</html>