<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Стек вызовов</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <section>
        <a href="../4_function.html"><<назад</a>
        <h1>Стек вызовов</h1>
        <p>
При вызове функции, внутри её тела могут вызываться другие функции, а в них другие и т. д. JavaScript однопоточный язык, то есть в одну единицу времени может выполняться только одна инструкция. Это значит, что уже вызванные функции, которые не закончили свое выполнение, должны ждать выполнения функций вызванных внутри себя, для того, чтобы продолжить свою работу.

<code>
  function fnA() {
<br>  console.log("Лог внуртри функции fnA до вызова fnB");
<br>   fnB();
<br>   console.log("Лог внуртри функции fnA после вызова fnB");
<br> }
<br> 
<br> function fnB() {
<br>   console.log("Лог внутри функции fnB");
<br> }
<br> 
<br> console.log("Лог перед вызовом fnA");
<br> fnA();
<br> console.log("Лог после вызова fnA");
<br> 
<br> // "Лог перед вызовом fnA"
<br> // "Лог внуртри функции fnA до вызова fnB"
<br> // "Лог внутри функции fnB"
<br> // "Лог внуртри функции fnA после вызова fnB"
<br> // "Лог после вызова fnA"
</code>


Необходим механизм хранения списка функций, которые были вызваны, но еще не закончили свое выполнение и механизм управления порядком выполнения этих функций - и именно за это отвечает стек вызовов (call stack).

<h2>
  Стек
</h2>

Стек - структура данных, которая работает по принципу LIFO (Last-In-First-Out), то есть последним пришёл - первым вышел. Последнее, что добавляется на стек, будет удалено из него первым, значит можно добавить или удалить элементы только из верхушки стека.
<br><br>
Представьте стек как массив у которого есть только методы pop и push, то есть можно добавить или удалить только элемент в конце коллекции.

<h2>
  Стек вызовов
</h2>

Стек вызовов (call stack) - это механизм для отслеживания текущего местонахождения интерпретатора в коде, который вызывает несколько функций. Какая из функций выполняется на данный момент, какие функции вызываются изнутри выполняемой функции, какая будет вызвана следующей и т. д.

<ul>
  <li>Когда скрипт вызывает функцию, интерпретатор добавляет её в стек вызовов и начинает выполнение.</li>
  <li>Любые функции, вызванные выполняемой функцией, добавляются в стек вызовов и выполняются, как только происходит их вызов.</li>
  <li>Когда выполнение функции завершено, интерпретатор снимает её со стека вызовов и возобновляет выполнение кода с той точки, где остановился до этого. То есть начинает выполняться функция, запись которой лежит следующей на стеке.</li>
</ul>

<h4>
  ИНТЕРЕСНО
Stack frame (кадр стека, запись стека) - структура которая добавляется на стек при вызове функции. Хранит служебную информацию, например имя функции и номер строки, в которой произошел вызов.
</h4>

<code>
  function bar() {
<br>   console.log("bar");
<br> }
<br> 
<br> function baz() {
<br>   console.log("baz");
<br> }
<br> 
<br> function foo() {
<br>   console.log("foo");
<br>   bar();
<br>   baz();
<br> }
<br> 
<br> foo();
</code>

При выполнении этого кода сначала вызывается foo(), затем внутри foo() вызывается bar(), а затем baz(). Вызовы console.log() так же учитываются, ведь это функция. На иллюстрации ниже пошагово изображен стек вызовов для примера.

<h2>
  Переполнение стека вызовов
</h2>
Стек вызовов не безграничный, ему отводится конечный объем памяти. Иногда в консоли можно увидеть ошибку "Uncaught RangeError: Maximum call stack size exceeded" - переполнение стека (stack overflow).
<br><br>
Это может произойти при неправильном использовании рекурсии или зацикливании вызовов функций, то есть, если идут бесконечные вызовы функций и результат не возвращается, то стек увеличивается. По достижению предела количества записей стека и возникнет такая ошибка и скрипт «падает».
</p>
  </section>
</body>
</html>