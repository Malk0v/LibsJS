<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <section>
        <a href="../8_methods.html"><<назад</a>
        <h1>Метод filter()</h1>
        <p>
          Метод <span>filter(callback)</span> используется для единственной операции - фильтрации массива, то есть когда необходимо выбрать более одного элемента из коллекции по какому-то критерию.

<code>
  массив.filter((element, index, array) => {
<br>  // Тело коллбек-функции
<br>});
</code>
<ul>
  <li>Не изменяет оригинальный массив</li>
  <li>Поэлементно перебирает оригинальный массив</li>
  <li>Возвращает новый массив</li>
  <li>Добавляет в возвращаемый массив элементы которые удовлетворяют условию коллбек-функции</li>
  <li>Если коллбек вернул true элемент добавляется в возвращаемый массив</li>
  <li>Если коллбек вернул false элемент не добавляется в возвращаемый массив</li>
  <li>Если ни один элемент не удовлетворил условию, возвращает пустой массив</li>
</ul>

<code>
  const values = [51, -3, 27, 21, -68, 42, -37];
<br> 
<br> const positiveValues = values.filter(value => value >= 0);
<br> console.log(positiveValues); // [51, 27, 21, 42]
<br> 
<br> const negativeValues = values.filter(value => value < 0);
<br> console.log(negativeValues); // [-3, -68, -37]
<br> 
<br> const bigValues = values.filter(value => value > 1000);
<br> console.log(bigValues); // []
<br> 
<br> // Оригинальный массив не изменился
<br> console.log(values); // [51, -3, 27, 21, -68, 42, -37]

</code>

То есть метод <span>filter</span> вызывает коллбек-функцию для каждого элемента исходного массива и если результат её выполнения true, текущий элемент добавляет в новый массив.

Фильтрация уникальных элементов
Используя метод filter() можно выполнить фильтрацию массива так, что в нём останутся только уникальные элементы. Этот приём работает только с массивом примитивных значений - не объектов.

Вернёмся к группе студентов и массиву всех посещаемых предметов, которые мы получили методом <span>flatMap()</span>.

<code>
  const students = [
<br>   { name: "Манго", courses: ["математика", "физика"] },
<br>   { name: "Поли", courses: ["информатика", "математика"] },
<br>   { name: "Киви", courses: ["физика", "биология"] },
<br> ];
<br> 
<br> const allCourses = students.flatMap(student => student.courses);
<br>
<br> // ['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];

</code>

В переменной allCourses хранится массив всех посещаемых предметов, которые могут повторяться. Задача заключается в том, чтобы сделать новый массив, в котором будут только уникальные предметы, то есть без повторений.

<code>
  const uniqueCourses = allCourses.filter(
 <br> (course, index, array) => array.indexOf(course) === index
<br>);
</code>

Используя <span>array.indexOf(course)</span> выполняем поиск первого совпадения текущего элемента course и получаем его индекс в оригинальном массиве всех курсов. В параметре index хранится индекс текущего элемента course при переборе массива методом filter.
<br><br>
Если результат <span>indexOf()</span> и значение index равны - это уникальный элемент, потому что это первый раз когда такое значение встречается в массиве и на текущей итерации фильтр обрабатывает именно его.

<code>
  # Массив всех курсов
<br>['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];
</code>

Для элемента 'математика' под индексом 0:

<ul>
  <li>indexOf() вернёт 0, потому что ищет первое совпадение</li>
  <li>Значение параметра index будет 0</li>
  <li>Они равны, значит это уникальный элемент</li>
</ul>

Для элемента 'математика' под индексом 3:

<ul>
  <li>indexOf() вернёт 0, потому что ищет первое совпадение</li>
  <li>Значение параметра index будет 3</li>
  <li>Они не равны, значит это повторяющийся - не уникальный элемент</li>
</ul>

<h2>
  Массив объектов
</h2>

При работе с массивом объектов выполняется фильтрация по значению какого-то свойства. В результате получается новый массив отфильтрованных объектов.
<br><br>
Например, есть массив студентов с баллами за тест. Необходимо отфильтровать лучших (балл выше 80), худших (балл ниже 50) и средних студентов (балл от 50 до 80).

<code>
<br>  const LOW_SCORE = 50;
<br> const HIGH_SCORE = 80;
<br> const students = [
<br>   { name: "Манго", score: 83 },
<br>   { name: "Поли", score: 59 },
<br>   { name: "Аякс", score: 37 },
<br>   { name: "Киви", score: 94 },
 <br>  { name: "Хьюстон", score: 64 },
<br> ];
<br> 
<br> const best = students.filter(student => student.score >= HIGH_SCORE);
<br> console.log(best); // Массив объектов с именами Манго и Киви
<br> 
<br> const worst = students.filter(student => student.score < LOW_SCORE);
<br> console.log(worst); // Массив с одним объектом Аякс
<br> 
<br> // В коллбек-функции удобно деструктуризировать свойства объекта
<br> const average = students.filter(
<br>   ({ score }) => score >= LOW_SCORE && score < HIGH_SCORE
<br> );
<br> console.log(average); // Массив объектов с именами Поли и Хьюстон
</code>

      </p>
    </section>
</body>
</html>