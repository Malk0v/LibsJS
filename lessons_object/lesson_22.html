<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Объекты</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <section>
        <a href="../5_object.html"><<назад</a>
        <h1>Объекты</h1>
        <p>
Объекты позволяют описать и сгруппировать характеристики некоторой сущности - пользователя, книги, продукта в магазине, чего угодно. Объекты ещё называют словарями, то есть они содержат термины (свойства) и их определения (значения).

<h2>
  Создание объекта
</h2>

Для объявления используются фигурные скобки {} - литерал объекта.

<code>
  const book = {
<br>  title: "The Last Kingdom",
<br>    author: "Bernard Cornwell",
<br>    genres: ["historical prose", "adventure"],
<br>    isPublic: true,
<br>    rating: 8.38,
<br>  };
</code>

При создании объекту можно добавить свойства, каждое из которых описывается парами ключ:значение. Ключ ещё называют именем свойства и это всегда строка. Значением свойства могут быть любые типы: примитивы, массивы, объекты, були, функции и т. п. Свойства разделяются запятой.
<br><br>
Правила именования ключей просты:
<ul>
  <li>Если ключ заключен в кавычки, то это может быть произвольная строка.</li>
  <li>Если кавычек нет, то вступают ограничения - имя без пробелов, начинается на букву или символы _ и $.</li>
</ul>

<h2>
  Вложенные свойства
</h2>

Значением свойства может быть другой объект, для того чтобы хранить вложенные и группированные данные. Например, статистика пользователя социальной сети состоит из количества последователей, просмотров и лайков, и хранить эти данные удобнее всего в виде объекта. Тоже самое с местоположением, отдельно страна и город.

<code>
  const user = {
<br>    name: "Jacques Gluke",
<br>    tag: "jgluke",
<br>    location: {
<br>      country: "Jamaica",
<br>      city: "Ocho Rios",
<br>    },
<br>    stats: {
<br>      followers: 5603,
<br>      views: 4827,
<br>      likes: 1308,
<br>    },
<br>  };
</code>

В будущем это можно будет использовать для поиска пользователей по стране, городу, минимальному или максимальному количеству последователей и т. д.

<h2>
  Обращение к свойствам через точку
</h2>
Первый способ получить доступ к свойству объекта это синтаксис обьект.имя_свойства. Синтаксис «через точку» используется в большинстве случаев и подходит тогда, когда мы заранее знаем имя (ключ) свойства к которому хотим получить доступ.

<ul>
  <li>На место обращения будет возвращено значение свойства с таким именем.</li>
  <li>Если в объекте нет свойства с таким именем, на место обращения вернётся undefined.</li>
</ul>

<code>
  const book = {
 <br>   title: "The Last Kingdom",
<br>    author: "Bernard Cornwell",
<br>    genres: ["historical prose", "adventure"],
<br>    isPublic: true,
<br>    rating: 8.38,
<br>  };
<br>  
<br>  const bookTitle = book.title;
<br>  console.log(bookTitle); // 'The Last Kingdom'
<br>  
<br>  const bookGenres = book.genres;
<br>  console.log(bookGenres); // ['historical prose', 'adventurs']
<br>  
<br>  const bookPrice = book.price;
<br>  console.log(bookPrice); // undefined
</code>


<h2>
  Обращение к вложенным свойствам
</h2>
Для доступа к вложенным свойствам используется цепочка обращейний «через точку». Например, если необходимо получить значение страны пользователя, записываем user.location.country, где user.location это обращение (путь) к объекту в свойстве location, а user.locaton.country обращение к свойству country в этом объекте. То есть «точка» указывает следующую вложенность.

<code>
 <br>   const user = {
<br>    name: "Jacques Gluke",
<br>    tag: "jgluke",
<br>    location: {
<br>      country: "Jamaica",
<br>      city: "Ocho Rios",
<br>    },
<br>    hobbies: ["swiming", "music", "sci-fi"],
<br>  };
<br>  
<br>  const location = user.location;
<br>  console.log(location); // Объект location
<br>  
<br>  const country = user.location.country;
<br>  console.log(country); // 'Jamaica'
</code>

Если значение свойства это массив, то в нашем примере user.hobbies обращение к этому массиву. Далее можно получить доступ к его элементам через квадратные скобки и индекс или использовать свойства и методы.

<code>
  const hobbies = user.hobbies;
<br>  console.log(hobbies); // ['swiming', 'music', 'sci-fi']
<br>  
<br>  const firstHobby = user.hobbies[0];
<br>  console.log(firstHobby); // 'swiming'
<br>  
<br>  const numberOfHobbies = user.hobbies.length;
<br>  console.log(numberOfHobbies); // 3
</code>

<h2>
  Обращение к свойствам через квадратные скобки
</h2>
Второй способ получить доступ к свойству объекта это синтаксис обьект["имя свойства"]. Похоже на обращение к элементу массива с отличием в том, что в скобках указывается не индекс элемента, а имя свойства как строка.
<br><br>
Синтаксис «квадратных скобок» используется значительно реже, в случае когда имя свойства заранее неизвестно или хранится в переменной, например как значение параметра функции.
<ul>
  <li>На место обращения будет возвращено значение свойства с таким именем.</li>
  <li>Если в объекте нет свойства с таким именем, на место обращения вернётся undefined.</li>
</ul>

<code>
  const book = {
 <br>   title: "The Last Kingdom",
<br>    author: "Bernard Cornwell",
<br>    genres: ["historical prose", "adventure"],
<br>    isPublic: true,
<br>    rating: 8.38,
<br>  };
<br>  
<br>  const bookTitle = book["title"];
<br>  console.log(bookTitle); // 'The Last Kingdom'
<br>  
<br>  const bookGenres = book["genres"];
<br>  console.log(bookGenres); // ['historical prose', 'adventurs']
<br>  
<br>  const propKey = "author";
<br>  const bookAuthor = book[propKey];
<br>  console.log(bookAuthor); // 'Bernard Cornwell'
</code>


<h2>
  Изменение значения свойства
</h2>
После того как объект создан, значение его свойств можно изменить. Для этого необходимо обратиться к ним по имени, например «через точку», и присвоить новое значение.

<code>
  const book = {
<br>    title: "The Last Kingdom",
<br>    author: "Bernard Cornwell",
<br>    genres: ["historical prose", "adventure"],
<br>    isPublic: true,
<br>    rating: 8.38,
<br>  };
<br>  
<br>  book.rating = 9;
<br>  book.isPublic = false;
<br>  book.genres.push("драма");
<br>  
<br>  console.log(book.rating); // 9
<br>  console.log(book.isPublic); // false
<br>  console.log(book.genres); // ['historical prose', 'adventures', 'драма']
</code>


<h2>
  Добавление свойств
</h2>
Операция добавления нового свойства после создания объекта ничем не отличается от изменения значения уже существующего свойства. Если при записи значения по имени, такого свойства в объекте нет, оно будет создано.

<code>
  const book = {
 <br>   title: "The Last Kingdom",
 <br>   author: "Bernard Cornwell",
 <br>   genres: ["historical prose", "adventure"],
 <br>   isPublic: true,
 <br>   rating: 8.38,
<br>  };
<br>  
<br>  book.pageCount = 836;
<br>  book.originalLanguage = "en";
<br>  book.translations = ["ua", "ru"];
<br>  
<br>  console.log(book.pageCount); // 836
<br>  console.log(book.originalLanguage); // 'en'
<br>  console.log(book.translations); // ['ua', 'ru']
</code>

<h2>
  Короткие свойства
</h2>

Иногда при создании объекта значение свойства необходимо взять из переменной или параметра функции с таким же именем как и само свойство.
<br><br>
Синтксис в следующем примере слишком громоздкий, потому что приходится дублировать имя свойства и имя переменной в которой хранится необходимое значение.

<code>
  const name = "Генри Сибола";
<br>  const age = 25;
<br>  
<br>  const user = {
<br>    name: name,
<br>    age: age,
<br>  };
<br>  
<br>  console.log(user.name); // "Генри Сибола"
<br>  console.log(user.age); // 25
</code>

Синтаксис коротких свойств (shorthand properties) решает эту проблему, позволяя использовать имя переменной как имя свойства, а её значение как значение свойства.

<code>
  const name = "Генри Сибола";
<br>  const age = 25;
<br>  
<br>  const user = {
<br>    name,
<br>    age,
<br>  };
<br>  
<br>  console.log(user.name); // "Генри Сибола"
<br>  console.log(user.age); // 25
</code>

То есть при объявлении объекта достаточно указать только имя свойства, а значение будет взято из переменной с аналогичным именем.

<h2>
  Вычисляемые свойства
</h2>

Бывают ситуации когда при объявлении обьекта необходимо добавить свойство с именем которое мы заранее не знаем, потому что оно хранится как значение переменной или как результат выполнения функции.
<br>
<br>
Раньше для этого необходимо было сначала создать объект, а потом добавлять свойства через квадратные скобки, что не совсем удобно.

<code>
  const propName = "name";
<br>  const user = {
<br>    age: 25,
<br>  };
<br>  
<br>  user[propName] = "Генри Сибола";
<br>  console.log(user.name); // 'Генри Сибола'
</code>

Синтаксис вычисляемых свойств (computed properties) помогает избежать лишнего кода и в некоторых случаях упростить его. Значением вычисляемого свойства может быть любое валидное выражение.

<code>
  const propName = "name";
<br>  const user = {
<br>    age: 25,
<br>    // Имя этого свойства будет взято из значения переменной propName
<br>    [propName]: "Генри Сибола",
<br>  };
<br>  
<br>  console.log(user.name); // 'Генри Сибола'
</code>


<h2>
  Методы объекта
</h2>
До сих пор мы рассматривали объекты только как хранилища взаимосвязанных данных, например информация о книге и т. п. Объекты-хранилища обычно находятся в массиве таких же объектов, который представляет коллекцию однотипных элементов.
<br><br>
Объекты могут хранить не только данные, но и функции для работы с этими данными - методы. Если значение свойства это функция, такое свойство называется методом объекта.

<code>
  // ✅ Логически и синтаксически сгруппированные сущности
<br>  const bookShelf = {
<br>    books: ["The Last Kingdom", "Dream Guardian"],
<br>    // Это метод объекта
<br>    getBooks() {
 <br>     console.log("Этот метод будет возвращать все книги - свойство books");
<br>    },
<br>    // Это метод объекта
<br>    addBook(bookName) {
<br>      console.log("Этот метод будет добавлять новую книгу в свойство books");
<br>    },
<br>  };
<br>  
<br>  // Вызовы методов
<br>  bookShelf.getBooks();
<br>  bookShelf.addBook("Новая книга");
</code>


Такие объекты можно назвать «моделями». Они связывают данные и методы для работы с этими данными. Например, можно было объявить переменную books и две функции getBooks() и addBook(bookName), но тогда это были бы три независимые сущности без явной синтаксической, и со слабой логической связью.

<code>
  // ❌ Слабосвязанные, независмые сущности
const books = [];
function getBooks() {}
function addBook() {}
</code>

<h2>
  Доступ к свойствам объекта в методах
</h2>
Методы используются для работы со свойствами объекта, их изменения. Для доступа к объекту в методе используется не имя переменной, например bookShelf, а ключевое слово this - контекст. Значением this будет объект перед «точкой», то есть объект который вызвал этот метод, в нашем случае это ссылка на объект bookShelf.

<code>
  const bookShelf = {
  books: ["The Last Kingdom"],
  getBooks() {
    console.log(this);
  },
};

// Перед точкой стоит объект bookShelf,
// поэтому при вызове метода, this будет хранить ссылку на него.
bookShelf.getBooks(); // {books: ['The Last Kingdom'], getBooks: f}
</code>

Для того чтобы получить доступ к свойствам объекта в методах, мы обращаемся к нему через this и дальше как обычно - «через точку» к свойствам.

<code>
  const bookShelf = {
  books: ["The Last Kingdom"],
  getBooks() {
    return this.books;
  },
  addBook(bookName) {
    this.books.push(bookName);
  },
  removeBook(bookName) {
    const bookIndex = this.books.indexOf(bookName);
    this.books.splice(bookIndex, 1);
  },
};

console.log(bookShelf.getBooks()); // ["The Last Kingdom"]
bookShelf.addBook("The Mist");
bookShelf.addBook("Dream Guardian");
console.log(bookShelf.getBooks()); // ['The Last Kingdom', 'The Mist', 'Dream Guardian']
bookShelf.removeBook("The Mist");
console.log(bookShelf.getBooks()); // ['The Last Kingdom', 'Dream Guardian']
</code>


Будет логично задуматься - почему бы не использовать при обращении к свойствам имя объекта, ведь мы явно не собираемся его менять. Дело в том, что имя объекта штука ненадежная, методы одного объекта можно копировать в другой (с другим именем), а в будущем узнаем что часто при создании объекта мы заранее вовсе не знаем имени. Использование this гарантирует, что метод работает именно с тем объектом, который его вызвал.


<h4>
  ИНТЕРЕСНО
Мы детально разберем ключевое слово this и все его подводные камни в следующих занятиях, а сейчас достаточно просто использовать this при обращении к свойствами объекта в его методах.

</h4>        
</p>
    </section>
</body>
</html>