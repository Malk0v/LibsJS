<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Пагинация</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <section>
        <a href="../20_per_page.html"><<назад</a>
        <h1>Пагинация</h1>
        <p>

База данных может хранить коллекции состоящие из сотен миллионов записей. Поэтому возвращать всю коллекцию на каждый GET-запрос слишком ресурсозатратно. Размер тела ответа будет слишком большой, и время запроса затянется на десятки секунд, а то и минуты - чем больше в ответе от бэкенда данных, тем дольше он идет по сети.
<br><br>
Кроме этого, необходимо думать о пользователях - врядле им нужны все миллионы записей сразу. Обработка такого большого количества данных в ответе и отрисовка интерфейса потребует огромных ресурсов устройства на котором просматривается веб-страница. По статистике пользователи находят интересующую их информацию на нескольких первых экранах.
<br><br>
Допустим наш бекенд my-api.com хранит очень большую коллекцию постов в ресурсе /posts, которую представим двенадцатью элементами на иллюстрации.
<br><br>

<img src="../img/no-pagination.png" alt="No pagination" width="100%">

На каждый GET-запрос бэкенду придется вернуть всю коллекцию и мы столкнемся с проблемами описанными ранее. Для их решения и существует пагинация - приём, при котором на первый и каждый последующий GET-запрос возвращается не вся коллекция, а определённая её часть. Пагинация реализуется на бэкенде и используется на фронтенде при помощи специальных параметров запроса.

<h2>
    Количество элементов ответа
</h2>

Первый параметр определяет количество элементов в ответе от бэкенда. Пусть, в нашем случае, он называется per_page. Стандарта именования параметров пагинации нет, поэтому их имена зависят от бэкенд разработчика.
<br><br>

<img src="../img/per-page-param.png" alt="per_page paramater" width="100%">

В таком GET-запросе бэкенд вернет не всю коллекцию из двенадцати элементов, а только первые четыре. Если передать отрицательное значение или значение большее чем количество элементов в коллекции, то бэкенд может ответить по разному - проигнорировать их или вернуть ошибку 400 (BAD REQUEST), зависит от его реализации.

Публичный JSONPlaceholder API так же поддерживает пагинацию - количество элементов в ответе контролируерт параметр _limit. Всего в коллекции /posts есть сто элементов. Изменяйте значение параметра _limit в примере и исследуйте ответ бэкенда в интерфейсе и на вкладке Network.


<h2>
    Номер группы элементов
</h2>

Указав желаемое количество элементов в ответе мы всегда получим одинаковый результат - первые per_page элементов коллекции, так называемую первую группу или «страницу». Второй параметр пагинации контролирует смещение внутри коллекции - номер группы элементов которую мы хотим получить. Если бэкенд реализует пагинацию, то значение этого параметра по умолчанию единица - первая группа или «страница» элементов. Пусть в нашем случае он называется page.
<br><br>

<img src="../img/page-param.png" alt="Page paramater" width="100%">

Изменяя значение параметра page мы уточняем бэкенду какую следующую группу элементов хотим получить, и так пока в коллекции не закончатся элементы. Если задать отрицательное значение или больше чем групп в коллекции - ответ бекенда будет зависеть от его реализации.
<br><br>
В JSONPlaceholder API параметр контролирующий группу элементов называется _page. Изменяйте его значение в примере и исследуйте ответ бэкенда в интерфейсе и на вкладке Network.


<h4>
    ИНТЕРЕСНО
Для того чтобы знать когда закончатся элементы в коллекции и вывести об этом сообщение пользователю, бэкенд в каждом ответе возвращает не только массив элементов, но и метаданные про доступное количество групп («страниц»), зависящее от значения параметра per_page, или просто общее количество элементов в коллекции, тогда вычисление количества групп ложится на плечи фронтенд разработчика. К сожалению JSONPlaceholder API не реализует этот функционал.

</h4>

<h2>
    Приём «Загрузить ещё»
</h2>

Для того чтобы динамически изменять номер группы на каждый последующий запрос, достаточно объявить еще одну глобальную переменную, назвем её page и установим начальное значение 1 - первая группа элементов. После каждого успешного запроса, в коллбэке метода then() будем увеличивать значение page на единицу. При составлении параметров запроса используем её значение.
<br>

<div class="alert">We're sorry, there are no more posts to load</div>
<ul class="posts"></ul>
<button type="button" class="btn">Fetch posts</button>

<br><br>

После загрузки первой группы элементов, текст на кнопке измениться, а сама кнопка опустится под список постов. Когда пользователь прокрутит страницу и опять кликнет по ней - выполнится запрос за второй группой элементов, которая добавиться к уже существующей разметке списка постов. Если при клике на кнопку «Fetch posts» постов для загрузки больше нет - показываем оповещение.
<br><br>
Мы добавили проверку конца коллекции на фронтенде, потому что JSONPlaceholder API не реализует этот функционал на бэкенде. В нашем случае достаточно разделить общее количество элементов в коллекции на количество элементов в одной группе. Это похоже на случай, когда бэкенд возвращает не количество доступных страниц, а общее количество элементов в коллекции.
        </p>
    </section>

    <style>
        .posts {
  margin: 0;
  list-style: none;
  margin-bottom: 16px;
}

.posts li:not(:last-child) {
  margin-bottom: 16px;
}

.post-title {
  margin-top: 0;
  margin-bottom: 8px;
  font-size: 20px;
  font-weight: 700;
}

.post-title:first-letter {
  text-transform: uppercase;
}

.post-body {
  margin: 0;
}

.alert {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  padding: 8px;
  text-align: center;
  background-color: tomato;
  color: #fff;
  transform: translatey(-100%);
  transition: transform 250ms ease-in-out;
}

.alert.is-visible {
  transform: translatey(0);
}
    </style>

    <script src="../js/83.js" type="module"></script>
</body>
</html>