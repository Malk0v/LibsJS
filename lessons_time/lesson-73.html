<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Асинхронность</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <section>
        <a href="../17_timers_time.html"><<назад</a>
        <h1>Асинхронность</h1>

        <p>
            Весь код выполняется процессором вашего компьютера. Код который мы писали до сих пор был синхронным, то есть занимал процессор на все время своего выполнения. Например, скорость выполнения цикла для итерации по массиву зависит от скорости процессора.
<br><br>
Есть операции которые взаимодействуют с внешним миром. Например, обмен данными с сервером по сети, что намного медленнее, чем получение их из памяти. Если такие операции обрабатываются синхронно, то процессор простаивает пока идет сетевой запрос на сервер, вместо того чтобы выполнять другой код.
<br><br>
Синхронный код выполняется последовательно, каждая инструкция ожидает пока выполнится предыдущая. Когда вы вызываете функцию, которая выполняет длительное действие, это останавливает программу на всё время её выполнения. То есть в модели синхронного программирования все происходит по очереди.

<h4>
    ИНТЕРЕСНО
Представьте очередь покупки билетов на поезд. Вы не можете начать покупать билет до тех пор, пока не купит человек перед вами. Точно так же люди, стоящие за вами, не могут начать покупать билеты до тех пор, пока не купите вы.

</h4>
В асинхронном коде одновременно могут выполняться несколько операций. В такой модели сетевой запрос на сервер не остановит программу, она продолжит выполнять другие операции. Когда запрос завершится, программа информируется об этом и получает доступ к результату (например, данным от сервера).

<h4>ИНТЕРЕСНО
Представьте обед в ресторане. Вы и другие посетители, заказываете еду. Вам не нужно ждать, пока им принесут еду, прежде чем заказывать. Точно так же другие посетители не должны ждать, пока вы получите свое блюдо и поедите, прежде чем они смогут заказать. Каждый получит свое блюдо, как только его закончат готовить.
</h4>

Рассмотрим разницу на примере в котором программа выполняет два сетевых запроса на сервер, после чего обрабатывает их результат. Операции 1 и 2 это функции которые делают запросы на севрер, а 3, 4 и 5 любой другой привычный вам код.
<br><br>
В синхронной модели все понятно и довольно печально - предыдущие операции блокируют выолнение последующих пока не закончатся. Если операции 3-5 это обработка кликов пользователя, то интерфейс просто зависнет пока не выполнятся и обработаются результаты запросов 1-2.
<br><br>
Например, пользователь отправил комментарий (сетевой запрос) и в тоже время захотел открыть сайдбар с последними новостями. После клика отправить комментрий, интерфейс зависнет и не будет реагировать на его действия пока от сервера не придет результат отправки комментария. Согласитесь, это не очень удобно.
<br><br>
В асинхронной модели старт сетевого запроса вызывает как бы разветвление, то есть запуск запроса и результат его обработки это различные действия. Пока выполяется запрос, программа продолжает работать и выполнять другой код. Как только сетевой запрос выполнен, программа может начать обрабатывать его результат как только будет свободна. Это значит, что пользователь отправил комментарий и сразу смог открыть сайдбар со свежими новостями, не дожидаясь пока придёт ответ от сервера.
<br><br>
То есть в единицу времени все также может выполняться только одна операция, потому что JavaScript однопоточный. Асинхронное программирование достигается путем отложенных вызовов функций, где инициализация асинхронной операции и обработка её результата это разные действия.

<h2>
    Асинхронный код
</h2>
В синхронном коде следующая инструкция не может начать свое выполнение пока не выполнится предыдущая. То есть инструкции обрабатываются последовательно.


<code>
    console.log("First log");
<br> console.log("Second log");
<br> console.log("Third log");

</code>
Следующий код - асинхронный. С функцией <span>setTimeout()</span> мы познакомимся дальше. Сейчас о ней нам нужно знать только то, что она принимает два параметра: callback-функцию, которая будет вызвана по истечении времени, которое мы передаем вторым аргументом.

<code> 
    // Will run first
<br> console.log("First log");
<br> 
<br> setTimeout(() => {
<br>   // Will run last, after 2000 milliseconds
<br>   console.log("Second log");
<br> }, 2000);
<br> 
<br> // Will run second
<br> console.log("Third log");
</code>

Функция <span>setTimeout()</span> отрабатывает синхронно и регистрирует отложенный вызов переданной callback-функции, которая будет вызвана асинхронно, через указанный промежуток времени.

<h2>
    Многопоточность
</h2>
Не путайте асинхронность и многопоточность (параллелизм) - это разные модели программирования. Приведем простую аналогию, которая все расставит по своим местам. Представьте, что вы шеф в ресторане и приходит заказ на кофе и тосты.
<ul>
    <li>Синхронный однопоточный подход - вы сами сначала готовите кофе, затем тосты и подаёте их, после чего убираете на кухне.
</li>
    <li>Асинхронный однопоточный подход - вы начинаете готовить кофе и устанавливаете таймер, затем начинаете готовить тосты и так же устанавливаете таймер. Пока кофе и тосты готовятся, вы убираете на кухне. Когда таймеры срабатывают, вы снимаете с огня кофе, достаете тосты и подаёте их.
</li>
    <li>Многопоточный подход (параллелизм) - вы нанимаете двух помошников, одного для приготовления кофе, а другого для тостов. Теперь у вас есть проблема управления помошниками (потоками), чтобы они не конфликтовали друг с другом на кухне при совместном использовании ресурсов.
</li>
</ul>
В асинхронных однопоточных процессах у вас есть график задач, где некоторые задачи зависят от результата работы других. По мере выполнения каждой задачи вызывается код для обработки её результата. Но вам нужен только один работник для выполнения всех задач, а не один работник на задачу.
    </p>    
    </section>
</body>
</html>