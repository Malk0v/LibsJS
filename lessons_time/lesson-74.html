<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Таймеры</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <section>
         <a href="../17_timers_time.html"><<назад</a>
        <h1>Таймеры</h1>
       <p>
           Внутренний таймер-планировщик браузера позволяет откладывать вызов функции на определенный период времени. Для этого есть тайм-ауты и интервалы, которые контролируют когда и как часто вызывается функция. Таймеры реализованы в браузере, а не встроенны в язык, и доступны на глобальном объекте window.

<h2>Таймаут</h2>
Метод <span>setTimeout() </span> позволяет запланировать запуск функции через определённое время.

<code>
const timerId = setTimeout(callback, delay, arg1, arg2, ...);
</code>

<ul>
    <li>callback - функция, выполнение которое необходимо запланировать</li>
    <li>delay - время в миллисекундах, через которое callback-функция будет вызвана один раз</li>
    <li>Дополнительные аргументы (arg1, arg2 и т. д.) будут переданы callback-функции во время вызова. Возвращает цифровой идентификатор созданного таймера, который используется для его удаления
</li>
</ul>

Если нам, по какой-то причине, нужно отменить вызов функции внутри таймаута, используется метод <span>clearTimeout(id)</span>, которая принимает идентификатор таймера и очищает (удаляет) его.

<code>

const greet = () => {
 <br> console.log("Hello!");
<br>};
<br>
<br>const timerId = setTimeout(greet, 3000);
<br>
<br>clearTimeout(timerId);

</code>
Поскольку мы вызвали <span>clearTimeout()</span>, который исполнится раньше чем будет вызвана функция greet(), таймер с timerId будет удалён и регистрация отложенного вызова greet() отменится. Поэтому в консоль ничего не выведется.

<h2>Интервал</h2>
Метод <span>setInterval()</span> - это простой способ повторения кода снова и снова с установленным промежутком времени повторений. Синтаксис и параметры такие же как у setTimeout(). В отличие от setTimeout(), интервал запускает выполнение функции не один раз, а регулярно повторяет её через указанный промежуток времени. Остановить исполнение можно вызовом метода <span>clearInterval(id)</span>.

<code>const timerId = setInterval(callback, delay, arg1, arg2, ...);</code>

При клике на кнопку «Start» запустим интервал и будем каждую секунду выводить в консоль строку. Используем Math.random() чтобы строки были разные. По клику на кнопку «Stop» вызовем clearInterval() и передадим идентификатор интервала который надо остановить.
<br><br>

<button class="btn js-start">Start</button>
<button class="btn js-stop">Stop</button>

<p class="text"></p>

<h2>Частота срабатывания счетчика</h2>

У браузерного таймера есть минимальная возможная задержка. В современных браузерах она колеблется примерно от 0 до 4 миллисекунд. В более старых браузерах задержка может быть больше и достигать 15 миллисекунд. По стандарту, минимальная задержка составляет 4 миллисекунды, так что разницы между setTimeout(callback, 1) и setTimeout(callback, 4) нет.
<br><br>
Таймер может срабатывать реже чем указано в параметре delay, потому что при слишком большой загрузке процессора некоторые запуски функций-интервалов будут пропущены. Браузеры продолжают выполнять таймауты и интервалы даже если вкладка браузера неактивна, но при этом снижают частоту срабатывания таймеров.
       </p>
    </section>

    <script src="../js/74.js" type="module"></script>
</body>
</html>